<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="请按时午睡">
<meta property="og:type" content="website">
<meta property="og:title" content="午睡是一门学问">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="午睡是一门学问">
<meta property="og:description" content="请按时午睡">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="BenSQ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>午睡是一门学问</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">午睡是一门学问</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/10/Tensorflow%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BenSQ">
      <meta itemprop="description" content="请按时午睡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午睡是一门学问">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/10/Tensorflow%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">Tensorflow学习日志</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-10 22:26:30" itemprop="dateCreated datePublished" datetime="2022-10-10T22:26:30+08:00">2022-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-08 23:26:27" itemprop="dateModified" datetime="2022-11-08T23:26:27+08:00">2022-11-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="神经网络基础篇"><a href="#神经网络基础篇" class="headerlink" title="神经网络基础篇"></a>神经网络基础篇</h1><h2 id="名词示意"><a href="#名词示意" class="headerlink" title="名词示意"></a>名词示意</h2><h3 id="权重线"><a href="#权重线" class="headerlink" title="权重线"></a>权重线</h3><ul>
<li><p><br  /></p>
</li>
</ul>
<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><ul>
<li>层次结构</li>
<li>神经元，即用来计算的的项</li>
<li>全连接：如果增加一个神经元，会影响一整组数据，是乘积关系。因为前面所有神经元要与它连接，且它也要与后面所有神经元连接。</li>
<li><p>非线性：有 $x<em>w1</em>w2<em>w3$, 若有 $ w4 = w1</em>w2<em>w3 $, 但不能用 $ w4 $ 替换 $w1</em>w2*w3$.</p>
<p><br  /></p>
</li>
</ul>
<h2 id="得分函数-前向传播"><a href="#得分函数-前向传播" class="headerlink" title="得分函数(前向传播)"></a>得分函数(前向传播)</h2><ul>
<li>用来判断输入的矩阵属于什么类别</li>
<li><script type="math/tex; mode=display">f(x)=Wx (+b)</script><ul>
<li>W为 n 行 m 列的权重参数矩阵，n 行代表有 n 个权重参数（类别）, m 代表有整个图像矩阵有 m 个像素点 （把原权重矩阵拉成 1 行 m 列）<ul>
<li>权重参数矩阵中，值较大的项表示，该像素点对该类别的影响比较重要。</li>
</ul>
</li>
<li>x 为图像参数，为 n 行 1 列的矩阵（把原图像矩阵拉成 n 行 1 列）</li>
<li>(+b) 为偏置参数（为 n 行 1 列， 与结果矩阵形式相同），用来微调</li>
<li>f(x) 为运算结果， 是一个 n 行 1 列的矩阵（ n 行代表有 n 个类别）</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="损失函数（loss）"><a href="#损失函数（loss）" class="headerlink" title="损失函数（loss）"></a>损失函数（loss）</h2><ul>
<li><p>用来衡量该目前识别出来效果的好坏，值越小越好，若完全正确，则值为0。也可以自己写损失函数。</p>
<p><br  /></p>
</li>
<li><p>均方误差损失函数(MSE)</p>
<ul>
<li><code>loss_mse = tf.reduce_mean(tf.square(y_-y))</code></li>
<li>$ \operatorname{MSE}\left(\mathrm{y}<em>{-}, \mathrm{y}\right)=\frac{\sum</em>{i=1}^{n}\left(y-y_{-}\right)^{2}}{n} $</li>
</ul>
<p><br  /></p>
</li>
<li><p>交叉熵损失函数(CE):表征两个概率分布之间的距离</p>
<ul>
<li>$ \mathrm{H}\left(\mathrm{y}<em>{-}, \mathrm{y}\right)=-\sum y</em>{-} * \ln y $  #y表示预测结果的概率分布，y_表示标准答案的概率分布。</li>
<li><code>tf.losses.categorical_crossentropy(y-, y)</code></li>
<li>计算中，常先使用softmax分类，再通过交叉熵计算。再tensorflow中有将二者结合的公式：<ul>
<li><code>tf.nn.softmax_cross entropy._with_logitsty_ y)</code></li>
</ul>
</li>
</ul>
<p><br  /></p>
</li>
<li><script type="math/tex; mode=display">L_{i} = \sum_{j \neq y_{i}} \max \left(0, s_{j}-s_{y_{i}}+1\right)</script><p><br  /></p>
</li>
<li><script type="math/tex; mode=display">L=\frac{1}{N} \sum_{i=1}^{N} \sum_{j \neq y_{i}} \max \left(0, f\left(x_{i} ; W\right)_{j}-f\left(x_{i} ; W\right)_{y_{i}}+1\right)+\lambda R(W)</script><ul>
<li>$ \lambda R(W) $ 为正则惩罚项，用来消除突变值，减弱过拟合</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="Softmax分类器（内容有误，之后再改）"><a href="#Softmax分类器（内容有误，之后再改）" class="headerlink" title="Softmax分类器（内容有误，之后再改）"></a>Softmax分类器（内容有误，之后再改）</h2><ul>
<li>$\operatorname{Softmax}\left(\mathrm{y}<em>{\mathrm{i}}\right)=\frac{\mathrm{e}^{y</em>{i}}}{\sum<em>{\mathrm{j}=0}^{n} \mathrm{e}^{y</em>{i}}} $</li>
<li><p><code>tf.nn.softmax(x)</code></p>
<p><br  /></p>
</li>
</ul>
<h2 id="欠拟合与过拟合"><a href="#欠拟合与过拟合" class="headerlink" title="欠拟合与过拟合"></a>欠拟合与过拟合</h2><p>  <br  /></p>
<h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><ul>
<li>回归任务：用得分值计算损失。回归模型可预测连续值。  <script type="math/tex; mode=display">L=\frac{1}{N} \sum_{i=1}^{N} \sum_{j \neq y_{i}} \max \left(0, f\left(x_{i} ; W\right)_{j}-f\left(x_{i} ; W\right)_{y_{i}}+1\right)+\lambda R(W)</script></li>
<li><p>分类任务：用概率值计算损失 。分类模型可预测离散值。</p>
<script type="math/tex; mode=display">-log(z)</script><p><br  /></p>
</li>
</ul>
<h2 id="反向传播（链式求导）"><a href="#反向传播（链式求导）" class="headerlink" title="反向传播（链式求导）"></a>反向传播（链式求导）</h2><p>  <br  /></p>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><ul>
<li><ol>
<li>首选relu激活函数；</li>
<li>学习率设置较小值；</li>
<li>输入特征标准化，即让输入特征满足以0为均值，1为标准差的正态分布；</li>
<li>初始参数中心化,即让随机生成的参数满足以0为均值，$ \sqrt{\frac{2}{\text { 当前层输入特征个数 }}} $ 为标准差的正态分布。</li>
</ol>
<p><br  /></p>
</li>
</ul>
<h3 id="Sigmoid函数-g-z-frac-1-1-e-z"><a href="#Sigmoid函数-g-z-frac-1-1-e-z" class="headerlink" title="Sigmoid函数 $ g(z)=\frac{1}{1+e^{-z}} $"></a>Sigmoid函数 $ g(z)=\frac{1}{1+e^{-z}} $</h3><ul>
<li><code>tf.nn.sigmoid(x)</code> #现在基本不再使用<ul>
<li><img src="https://note.youdao.com/s/cdefIVvi" alt="示例"></li>
</ul>
</li>
</ul>
<ul>
<li><ol>
<li>“梯度消失”现象: z过大或负向过大时，斜率基本为0，即梯度为0，则0之后的梯度都为0，认为不再传播.<ol>
<li>输出非0均值，收敛慢</li>
<li>幂运算复杂，训练时间长</li>
</ol>
</li>
</ol>
<p><br  /></p>
</li>
</ul>
<h3 id="Tanh函数-f-x-frac-1-e-2-x-1-e-2-x"><a href="#Tanh函数-f-x-frac-1-e-2-x-1-e-2-x" class="headerlink" title="Tanh函数 $ f(x)=\frac{1-e^{-2 x}}{1+e^{-2 x}} $"></a>Tanh函数 $ f(x)=\frac{1-e^{-2 x}}{1+e^{-2 x}} $</h3><ul>
<li><p><code>tf.math.tanh(x)</code> #与sigmoid同理</p>
<p><br  /></p>
</li>
</ul>
<h3 id="Relu函数"><a href="#Relu函数" class="headerlink" title="Relu函数"></a>Relu函数</h3><p>$ \begin{aligned}<br>f(x) &amp;=\max (x, 0) \<br>&amp;=\left{\begin{array}{ll}<br>0 &amp; x<0 \\
x & x>=0<br>\end{array}\right.<br>\end{aligned} $</p>
<ul>
<li><p><code>tf.nn.relu(x)</code></p>
<ul>
<li><ol>
<li>解决了梯度消失问题(在正区间)</li>
<li>只需判断输入是否大于0，计算速度快</li>
<li>收敛速度远快于sigmoid和Itanh</li>
</ol>
</li>
<li><ol>
<li>输出非0均值,收敛慢</li>
<li>Dead RelU问题:某些神经元可能永远不会激活</li>
</ol>
</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h3 id="Leaky-Relu函数-f-x-max-alpha-x-x"><a href="#Leaky-Relu函数-f-x-max-alpha-x-x" class="headerlink" title="Leaky Relu函数 $ f(x)=\max (\alpha x, x) $"></a>Leaky Relu函数 $ f(x)=\max (\alpha x, x) $</h3><ul>
<li><code>tf.nn.leaky_relu(x)</code> </li>
<li><p>解决了relu在负区导数为0的问题，理论上优于relu，但无实际证明总是好于relu。</p>
<p><br  /></p>
</li>
</ul>
<h2 id="缓解过拟合"><a href="#缓解过拟合" class="headerlink" title="缓解过拟合"></a>缓解过拟合</h2><h3 id="正则化缓解过拟合"><a href="#正则化缓解过拟合" class="headerlink" title="正则化缓解过拟合"></a>正则化缓解过拟合</h3><ul>
<li>正则化在损失函数中引入模型复杂度指标，利用给W加权值，弱化了训练数据的噪声（一般不正则化b)</li>
<li><script type="math/tex; mode=display">\text { loss }=\operatorname{loss}\left(y \text { 与 } y_{-}\right)+\text {REGULARIZER * } \operatorname{loss}(w)</script><ul>
<li>超参数REGULARIZER:给出参数w在总loss中的比例，即正则化的权重</li>
<li>w为需要正则化的参数</li>
<li>$ loss(w) $有两种形式：<ol>
<li>$ \operatorname{loss}<em>{L 1}(w)=\sum</em>{i}\left|w_{i}\right| $</li>
<li>$ \operatorname{loss}<em>{L 2}(w)=\sum</em>{i}\left|w_{i}^{2}\right| $</li>
</ol>
</li>
<li>正则化的选择<ul>
<li>L1正则化大概率会使很多参数变为零，因此该方法可通过稀疏参数，即”减少参数的数量”，降低复杂度。</li>
<li>L2正则化会使参数很接近零但不为零，因此该方法可通过”减小参数值”的大小降低复杂度。</li>
</ul>
</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="优化器-用来引导参数更新"><a href="#优化器-用来引导参数更新" class="headerlink" title="优化器: 用来引导参数更新"></a>优化器: 用来引导参数更新</h2><ul>
<li>待优化参数w，损失函数loss，学习率r，每次迭代一个batch,t表示当前batch迭代的总次数:<ol>
<li>计算时刻损失函数关于当前参数的梯度 $ g<em>{t}=\nabla \operatorname{loss}=\frac{\partial \operatorname{loss}}{\partial\left(w</em>{\mathrm{t}}\right)} $</li>
<li>计算t时刻一阶动量mt和二阶动量Vt</li>
<li>计算t时刻下降梯度: $ \boldsymbol{\eta}<em>{\mathrm{t}}=\boldsymbol{l} \boldsymbol{r} \cdot \boldsymbol{m}</em>{\mathrm{t}} / \sqrt{\boldsymbol{V}_{\mathrm{t}}} $</li>
<li>计算t+1时刻参数: $ w<em>{\mathrm{t}+1}=w</em>{t}-\eta<em>{t}=w</em>{t}-l r \cdot m<em>{t} / \sqrt{V</em>{t}} $<ul>
<li>一阶动量:与梯度相关的函数</li>
<li>二阶动量:与梯度平方相关的函数</li>
</ul>
</li>
</ol>
</li>
<li><p>不同的优化器实际上是定义了不同的一阶动量和二阶动量的表达公式。</p>
<p><br  /></p>
</li>
</ul>
<h3 id="SGD-（无momentum），常用的梯度下降法。"><a href="#SGD-（无momentum），常用的梯度下降法。" class="headerlink" title="SGD （无momentum），常用的梯度下降法。"></a>SGD （无momentum），常用的梯度下降法。</h3><ul>
<li><p>$ \begin{array}{c}<br>m<em>{\mathrm{t}}=\boldsymbol{g}</em>{\mathrm{t}} \quad V<em>{\mathrm{t}}=1 \<br>\eta</em>{\mathrm{t}}=\boldsymbol{l r} \cdot \boldsymbol{m}<em>{\mathrm{t}} / \sqrt{V</em>{t}}=\boldsymbol{l r} \cdot \boldsymbol{g}<em>{\boldsymbol{t}} \<br>w</em>{\mathrm{t}+1}=w<em>{t}-\boldsymbol{\eta}</em>{t} \<br>=w<em>{t}-l r \cdot m</em>{t} / \sqrt{V<em>{t}}=w</em>{t}-l r \cdot g<em>{t} \<br>\mathrm{w}</em>{\mathrm{t}+1}=w<em>{t}-l r * \frac{\partial \operatorname{loss}}{\partial w</em>{t}}<br>\end{array} $</p>
<p><br  /></p>
</li>
</ul>
<h3 id="SGDM（含momentum的SGD-，在SGD基础上增加一阶动量。"><a href="#SGDM（含momentum的SGD-，在SGD基础上增加一阶动量。" class="headerlink" title="SGDM（含momentum的SGD)，在SGD基础上增加一阶动量。"></a>SGDM（含momentum的SGD)，在SGD基础上增加一阶动量。</h3><ul>
<li><p>$ \begin{array}{l}<br>m<em>{\mathrm{t}}=\boldsymbol{\beta} \cdot \boldsymbol{m}</em>{t-1}+(1-\boldsymbol{\beta}) \cdot \boldsymbol{g}<em>{t}\<br>V</em>{t}=1\<br>\eta<em>{\mathrm{t}}=\boldsymbol{l} \boldsymbol{r} \cdot \boldsymbol{m}</em>{\mathrm{t}} / \sqrt{V<em>{\mathrm{t}}}=\boldsymbol{l r} \cdot \boldsymbol{m}</em>{\mathrm{t}}\<br>=\boldsymbol{l r} \cdot\left(\boldsymbol{\beta} \cdot \boldsymbol{m}<em>{\mathrm{t}-\mathbf{1}}+(\boldsymbol{1}-\boldsymbol{\beta}) \cdot \boldsymbol{g}</em>{\mathrm{t}}\right)\<br>w<em>{\mathrm{t}+1}=\boldsymbol{w}</em>{\mathrm{t}}-\boldsymbol{\eta}<em>{\mathrm{t}}\<br>=w</em>{\mathrm{t}}-\boldsymbol{l r} \cdot\left(\boldsymbol{\beta} \cdot \boldsymbol{m}<em>{\mathrm{t}-1}+(\boldsymbol{1}-\boldsymbol{\beta}) \cdot \boldsymbol{g}</em>{\mathrm{t}}\right)<br>\end{array} $</p>
<p><br  /></p>
</li>
</ul>
<h3 id="Adagrad，在SGD基础上增加二阶动量"><a href="#Adagrad，在SGD基础上增加二阶动量" class="headerlink" title="Adagrad，在SGD基础上增加二阶动量"></a>Adagrad，在SGD基础上增加二阶动量</h3><ul>
<li><p>$ \begin{aligned}<br>m<em>{\mathrm{t}} &amp;=g</em>{t} \quad V<em>{t}=\sum</em>{\tau=1}^{\mathrm{t}} g<em>{\tau}^{2} \<br>\eta</em>{\mathrm{t}} &amp;=\boldsymbol{l r} \cdot \boldsymbol{m}<em>{t} /\left(\sqrt{\boldsymbol{V}</em>{t}}\right) \<br>&amp;=\boldsymbol{l r} \cdot g<em>{t} /\left(\sqrt{\sum</em>{\tau=1}^{t} g<em>{\tau}^{2}}\right) \<br>w</em>{t+1}=&amp; w<em>{t}-\boldsymbol{\eta}</em>{t} \<br>&amp;=w<em>{t}-\boldsymbol{l r} \cdot g</em>{t} /\left(\sqrt{\sum<em>{\tau=1}^{t} g</em>{\tau}^{2}}\right)<br>\end{aligned} $</p>
<p><br  /></p>
</li>
</ul>
<h3 id="RMSProp-SGD基础上增加二阶动量"><a href="#RMSProp-SGD基础上增加二阶动量" class="headerlink" title="RMSProp,SGD基础上增加二阶动量"></a>RMSProp,SGD基础上增加二阶动量</h3><ul>
<li><p>$ \begin{aligned}<br>m<em>{\mathrm{t}} &amp;=\boldsymbol{g}</em>{t} \quad V<em>{t}=\boldsymbol{\beta} \cdot V</em>{t-1}+(1-\boldsymbol{\beta}) \cdot g<em>{t}^{2} \<br>\eta</em>{t}=&amp; \boldsymbol{l r} \cdot \boldsymbol{m}<em>{\mathrm{t}} / \sqrt{V</em>{\mathrm{t}}} \<br>&amp;=\boldsymbol{l r} \cdot \boldsymbol{g}<em>{t} /\left(\sqrt{\boldsymbol{\beta} \cdot \boldsymbol{V}</em>{t-1}+(1-\boldsymbol{\beta}) \cdot \boldsymbol{g}<em>{t}^{2}}\right) \<br>w</em>{t+1} &amp;=w<em>{t}-\boldsymbol{\eta}</em>{t} \<br>&amp;=w<em>{t}-\boldsymbol{l r} \cdot \boldsymbol{g}</em>{t} /\left(\sqrt{\boldsymbol{\beta} \cdot V<em>{t-1}+(1-\boldsymbol{\beta}) \cdot \boldsymbol{g}</em>{t}^{2}}\right)<br>\end{aligned} $</p>
<p><br  /></p>
</li>
</ul>
<h3 id="Adam-同时结合SGDM一阶动量和RMSProp二阶动量"><a href="#Adam-同时结合SGDM一阶动量和RMSProp二阶动量" class="headerlink" title="Adam,同时结合SGDM一阶动量和RMSProp二阶动量"></a>Adam,同时结合SGDM一阶动量和RMSProp二阶动量</h3><ul>
<li>$ m<em>{\mathrm{t}}=\beta</em>{1} \cdot m<em>{t-1}+\left(1-\beta</em>{1}\right) \cdot g_{t} $<ul>
<li>$ \text { 修正一阶动量的偏差: } \widehat{m<em>{t}}=\frac{m</em>{\mathrm{t}}}{1-\beta_{1}{ }^{t}} $</li>
</ul>
</li>
<li>$ V<em>{t}=\boldsymbol{\beta}</em>{2} \cdot V<em>{\text {step }-1}+\left(1-\boldsymbol{\beta}</em>{2}\right) \cdot \boldsymbol{g}_{t}^{2} $<ul>
<li>$ \text { 修正二阶动量的偏差: } \widehat{V<em>{t}}=\frac{V</em>{t}}{1-\beta_{2}{ }^{t}} $</li>
</ul>
</li>
<li><p>$ \begin{aligned}<br>\eta<em>{t}=&amp; \boldsymbol{l r} \cdot \widehat{m}</em>{\mathrm{t}} / \sqrt{\widehat{V}<em>{t}} \<br>&amp;=l r \cdot \frac{m</em>{\mathrm{t}}}{1-\beta<em>{1}{ }^{t}} / \sqrt{\frac{V</em>{t}}{1-\beta<em>{2}{ }^{t}}} \<br>w</em>{t+1} &amp;=\boldsymbol{w}<em>{t}-\boldsymbol{\eta}</em>{t} \<br>&amp;=w<em>{t}-\operatorname{lr} \cdot \frac{m</em>{\mathrm{t}}}{1-\beta<em>{1}{ }^{t}} / \sqrt{\frac{V</em>{t}}{1-\beta_{2}{ }^{t}}}<br>\end{aligned} $</p>
<p><br  /></p>
</li>
</ul>
<h2 id="神经网络复杂度"><a href="#神经网络复杂度" class="headerlink" title="神经网络复杂度"></a>神经网络复杂度</h2><ul>
<li><p>统计神经网络时，只统计有计算能力的层次，即忽略输入层。</p>
<ul>
<li>空间复杂度<ul>
<li>层数 = n个隐藏层 + 1个输出层。</li>
<li>总参数 = 总的w数 + 总的b数</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>乘加运算次数</li>
</ul>
</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="学习率及权重更新"><a href="#学习率及权重更新" class="headerlink" title="学习率及权重更新"></a>学习率及权重更新</h2><ul>
<li>$ w<em>{t+1}=w</em>{t}-\operatorname{lr} * \frac{\partial \operatorname{loss}}{\partial w_{t}} $ #lr为学习率，即每次更新的跨度。过小会慢，过大会不收敛。？</li>
<li>可以先用较大的学习率，快速得到较优解，然后逐步减小学习率，使模型在训练后期稳定。</li>
<li><p>寻找合适的学习率</p>
<ul>
<li>指数衰减学习率=初始学习率*学习率衰减率（当前轮数/多少轮衰减一次）</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h1 id="tensorflow篇"><a href="#tensorflow篇" class="headerlink" title="tensorflow篇"></a>tensorflow篇</h1><h2 id="名词释义"><a href="#名词释义" class="headerlink" title="名词释义"></a>名词释义</h2><ul>
<li>模型<ul>
<li>模型定义了特征与标签之间的关系。</li>
</ul>
</li>
<li><p>训练</p>
<ul>
<li>训练是指创建或学习模型。也就是说，向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。</li>
</ul>
<p><br  /></p>
</li>
<li><p>张量（Tensor):多维数组（列表)</p>
<ul>
<li>阶:张量的维数<ul>
<li>0阶：标量（scalar）</li>
<li>1阶：向量（vector）</li>
<li>2阶：矩阵（matrix）———— m = $[[1,2,3],[4,5,6],[7,8,9]]$</li>
<li>n阶：张量（tensor）</li>
</ul>
</li>
</ul>
<p><br  /></p>
</li>
<li><p>axis：这是张量操作函数里的一个可选参数，用的时候进行赋值，如果不赋值，则默认对所有维度进行操作。</p>
<ul>
<li>两种理解方式：<ul>
<li>1.若有二维数组或张量：axis=0，对数组第一个维度进行操作。axis=1，对数组第二个维度进行操作。</li>
<li>2.若有二维数组或张量：axis=0，进行纵向操作。axis=1，进行横向操作。（两种理解方式都一样，对应的操作都一样）</li>
</ul>
</li>
</ul>
<p><br  /></p>
</li>
<li><p>参数里的维度</p>
<ul>
<li>参数里的维度的写入形式：[2, 3]（2行3列）</li>
</ul>
<p><br  /></p>
</li>
<li><p>特征</p>
<ul>
<li>特征是输入变量，即简单线性回归中的 x 变量。 </li>
</ul>
<p><br  /></p>
</li>
<li><p>标签 </p>
<ul>
<li>标签是我们要预测的事物，即简单线性回归中的 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物, 即结论。</li>
</ul>
<p><br  /></p>
</li>
<li><p>超参数</p>
<ul>
<li>超参数是指不在函数内的参数，是我们自己额外给的参数。</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="穿插python语法"><a href="#穿插python语法" class="headerlink" title="穿插python语法"></a>穿插python语法</h2><h3 id="with结构"><a href="#with结构" class="headerlink" title="with结构"></a>with结构</h3><ul>
<li><p>等效于try+finally。执行with后的语句，若不成功则自动关闭进程，不占用系统资源，也不会停止程序。</p>
<ul>
<li><code>with open( &#39;./test_runoob.txt&#39;, &#39;w&#39; ) as file: (换行缩进) file.write( &#39; hello world ! &#39;)</code></li>
</ul>
<p><br  /></p>
</li>
</ul>
<h3 id="enumerate-列表名"><a href="#enumerate-列表名" class="headerlink" title="enumerate(列表名)"></a>enumerate(列表名)</h3><ul>
<li><p>enumerate是python的内建函数，它可遍历每个元素(如列表、元组或字符串)，返回2*len（列表）个值，组合为:索引 元素。常配合for循环中使用。</p>
<p><br  /></p>
</li>
</ul>
<h2 id="pandas库：处理数据的拓展库（可处理exel表格数据）"><a href="#pandas库：处理数据的拓展库（可处理exel表格数据）" class="headerlink" title="pandas库：处理数据的拓展库（可处理exel表格数据）"></a>pandas库：处理数据的拓展库（可处理exel表格数据）</h2><h3 id="读取目标文件"><a href="#读取目标文件" class="headerlink" title="读取目标文件"></a>读取目标文件</h3><ul>
<li><p><code>df=pd.read_csv(&#39;path&#39;)</code></p>
<p><br  /></p>
<h3 id="dataframe格式"><a href="#dataframe格式" class="headerlink" title="dataframe格式"></a>dataframe格式</h3><p><br  /></p>
</li>
</ul>
<h2 id="numpy库"><a href="#numpy库" class="headerlink" title="numpy库"></a>numpy库</h2><h3 id="np-random-RandomState-rand-维度-维度为空，返回标量"><a href="#np-random-RandomState-rand-维度-维度为空，返回标量" class="headerlink" title="np.random.RandomState.rand(维度)  #维度为空，返回标量"></a>np.random.RandomState.rand(维度)  #维度为空，返回标量</h3><ul>
<li><p><code>rdm=np.random.RandomState(seed=1)</code> #seed=常数, 每次生成随机数相同</p>
<ul>
<li>例子：<code>a=rdm.rand()</code>#返回一个随机标量</li>
<li>例子：<code>b=rdm.rand(2,3)</code>#返回维度为2行3列随机数矩阵</li>
</ul>
<p><br  /></p>
<h3 id="np-vstack-数组1，数组2-：将两个数组按垂直方向叠加（相接）"><a href="#np-vstack-数组1，数组2-：将两个数组按垂直方向叠加（相接）" class="headerlink" title="np.vstack(数组1，数组2)：将两个数组按垂直方向叠加（相接）"></a>np.vstack(数组1，数组2)：将两个数组按垂直方向叠加（相接）</h3></li>
<li><p>注意：不是数值相加，而是直接接上去</p>
<p><br  /></p>
</li>
</ul>
<h2 id="np-mgrid-，np-mgrid-，np-c"><a href="#np-mgrid-，np-mgrid-，np-c" class="headerlink" title="np.mgrid[]，np.mgrid[]，np.c_[]"></a>np.mgrid[]，np.mgrid[]，np.c_[]</h2><ul>
<li>x, y = np.mgrid[起始值:结束值:步长, 起始值:结束值:步长，…]</li>
<li>x.ravel()将x变为一维数组，“把.前变量拉直”</li>
<li>np.c_[x.ravel, y.ravel]使返回的间隔数值点配对(返回n行2列的列表)</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>数据类型：<ul>
<li>(1)tf.int32, tf.float32, tf.float64…</li>
<li>(2)tf.bool</li>
<li>(3)tf.string</li>
</ul>
</li>
</ul>
<h3 id="创建张量："><a href="#创建张量：" class="headerlink" title="创建张量："></a>创建张量：</h3><ul>
<li>创建：<code>tf.constant(张量内容，dtype=数据类型(可选))</code><ul>
<li>例：<code>a = tf.constant([1,5], dtype=tf.int64)</code> —— 创建一阶张量</li>
</ul>
</li>
<li><p>numpy转tensor：<code>tf.convert to_ tensor(数据名，dtype=数据类型(可选))</code></p>
<ul>
<li>例：<code>b = tf.convert_to_tensor(a, dtype=tf.int64)</code></li>
</ul>
<p><br  /></p>
</li>
<li><p>1.创建全为0的张量：tf.zeros(维度)</p>
<ul>
<li><code>tf.zeros(4)</code>：创建全为0，长度为4的一阶张量</li>
</ul>
</li>
<li>2.创建全为1的张量：tf.ones(维度)<ul>
<li><code>tf.ones([2,3])</code>：创建全为1，一维为2个，二维为3个的二阶张量</li>
</ul>
</li>
<li><p>3.创建全为指定值的张量：tf.fill(维度, 指定值)</p>
<ul>
<li><code>tf.fill([2,2], 9)</code>：创建内容为9，一维为2个，二维为2个的二阶张量</li>
</ul>
<p><br  /></p>
</li>
<li><p>生成正态分布的随机数，默认均值为0，标准差为1</p>
<ul>
<li><code>tf.random.normal(维度，mean=均值，stddev=标准差)</code></li>
</ul>
</li>
<li>生成截断式正态分布的随机数<ul>
<li><code>tf.random.truncated_normal(维度，mean=均值，stddev=标准差)</code><ul>
<li>在tf.truncated_normal中如果随机生成数据的取值在$（u-2\sigma ，u+2\sigma ）$之外，则重新进行生成，保证了生成值在均值附近。</li>
</ul>
</li>
</ul>
</li>
<li><p>生成均匀分布随机数</p>
<ul>
<li><code>tf.random.uniform(维度，minval=最小值，maxval=最大值)</code></li>
</ul>
<p><br  /></p>
</li>
</ul>
<h3 id="张量间类型转换"><a href="#张量间类型转换" class="headerlink" title="张量间类型转换"></a>张量间类型转换</h3><ul>
<li><p>强制tensor的内容转换为该数据类型</p>
<ul>
<li><code>tf.cast(张量名，dtype=数据类型)</code></li>
</ul>
<p><br  /></p>
</li>
</ul>
<h3 id="寻找张量中的特殊值"><a href="#寻找张量中的特殊值" class="headerlink" title="寻找张量中的特殊值"></a>寻找张量中的特殊值</h3><ul>
<li><p>计算张量中元素的最小值</p>
<ul>
<li><code>tf.reduce _min(张量名)</code></li>
</ul>
<p><br  /></p>
</li>
<li><p>计算张量中元素的最大值</p>
<ul>
<li><code>tf.reduce_max(张量名)</code>  </li>
</ul>
</li>
<li><p>返回张量沿指定维度最大值的索引(np类型也可用)</p>
<ul>
<li><code>tf.argmax(张量名,axis=操作轴)</code></li>
</ul>
<p><br  /></p>
</li>
<li><p>计算张量沿着指定维度的平均值</p>
<ul>
<li><code>tf.reduce _mean(张量名(, axis=&lt;操作轴&gt;))</code></li>
</ul>
</li>
<li><p>计算张量沿着指定维度的和</p>
<ul>
<li><code>tf.reduce_sum（(张量名(, axis=操作轴))</code></li>
</ul>
<p><br  /></p>
</li>
</ul>
<h3 id="将变量标记为“可训练”：被标记的变量会在反向传播中记录梯度信息。"><a href="#将变量标记为“可训练”：被标记的变量会在反向传播中记录梯度信息。" class="headerlink" title="将变量标记为“可训练”：被标记的变量会在反向传播中记录梯度信息。"></a>将变量标记为“可训练”：被标记的变量会在反向传播中记录梯度信息。</h3><ul>
<li><pre><code class="lang-tf.Variable(初始值)```">+ 例： ```W= tf.Variable(tf.random.normal([2, 2], mean=0, stddev=1))
</code></pre>
</li>
</ul>
<h3 id="简单数学运算"><a href="#简单数学运算" class="headerlink" title="简单数学运算"></a>简单数学运算</h3><ul>
<li>加、减、乘、除（四则运算，只有维度相同的张量才能进行四则运算）：<ul>
<li>1.<code>tf.add(张量1, 张量2)</code></li>
<li>2.<code>tf.subtract(张量1, 张量2)</code></li>
<li>3.<code>tf.multiply(张量1, 张量2)</code> —— 不是矩阵乘法，而是相应位置相乘，下同理</li>
<li>4.<code>tf.divide(张量1, 张量2)</code></li>
</ul>
</li>
<li>平方、n次方、开方：<ul>
<li>1.<code>tf.square(张量)</code> —— 对相应位置进行操作， 下同理</li>
<li>2.<code>tf.pow(张量, n次方数)</code></li>
<li>3.<code>tf.sqrt(张量)</code></li>
</ul>
</li>
<li><p>矩阵乘: </p>
<ul>
<li>1.<code>tf.matmul(矩阵1， 矩阵2)</code> —— 要符合线代矩阵乘法规则</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h3 id="求导运算（求梯度）"><a href="#求导运算（求梯度）" class="headerlink" title="求导运算（求梯度）"></a>求导运算（求梯度）</h3><ul>
<li><p>常在with结构下使用tf.GradientTape()来求梯度：with结构记录计算过程，gradient求出张量的梯度</p>
<ul>
<li>‘’<code>with tf.GradientTape( ) as tape:</code>‘’<br><br>  &emsp;<code>(若干个计算过程)</code><br><br>  &emsp;<code>grad = tape.gradient(函数（损失函数？）, 对谁求导)</code></li>
</ul>
<p><br  /></p>
</li>
</ul>
<h3 id="切分传入张量的第一维度，生成输入特征标签对，构建数据集-Numpy和Tensor格式都可用该语句读入数据）——-相应位置一一配对"><a href="#切分传入张量的第一维度，生成输入特征标签对，构建数据集-Numpy和Tensor格式都可用该语句读入数据）——-相应位置一一配对" class="headerlink" title="切分传入张量的第一维度，生成输入特征标签对，构建数据集 (Numpy和Tensor格式都可用该语句读入数据）—— 相应位置一一配对"></a>切分传入张量的第一维度，生成输入特征标签对，构建数据集 (Numpy和Tensor格式都可用该语句读入数据）—— 相应位置一一配对</h3><ul>
<li><p><code>data = tf.data.Dataset.from_tensor_slices((输入特征,标签))</code></p>
<p><br  /></p>
</li>
</ul>
<h3 id="独热编码（one-hot-encoding）-在分类问题中，常用独热码做标签-标记类别-1表示是，0表示非。"><a href="#独热编码（one-hot-encoding）-在分类问题中，常用独热码做标签-标记类别-1表示是，0表示非。" class="headerlink" title="独热编码（one-hot encoding）:在分类问题中，常用独热码做标签,标记类别:1表示是，0表示非。"></a>独热编码（one-hot encoding）:在分类问题中，常用独热码做标签,标记类别:1表示是，0表示非。</h3><ul>
<li><p><code>tf.one_hot(待转换数据, depth=几分类)</code></p>
<ul>
<li>tf.one_hot()函数将待转换数据，转换为one-hot形式的数据输出。<br><br><img src="https://note.youdao.com/s/O3Y395gR" alt="示例"></li>
</ul>
<p><br  /></p>
</li>
</ul>
<h3 id="tf-nn-softmax-x-使输出符合概率分布，有多少个分类就用多少个返回值"><a href="#tf-nn-softmax-x-使输出符合概率分布，有多少个分类就用多少个返回值" class="headerlink" title="tf.nn.softmax(x) - 使输出符合概率分布，有多少个分类就用多少个返回值"></a><code>tf.nn.softmax(x)</code> - 使输出符合概率分布，有多少个分类就用多少个返回值</h3><ul>
<li><p>通过前向传播，得出得分值，通过 $ \operatorname{Softmax}\left(\mathrm{y}<em>{\mathrm{i}}\right)=\frac{\mathrm{e}^{y</em>{i}}}{\sum<em>{\mathrm{j}=0}^{n} \mathrm{e}^{y</em>{i}}} $ 转换成符合概率分布的值。符合概率分布的值和为一。</p>
<p><br  /></p>
</li>
</ul>
<h3 id="assign-sub-x-要自减的值"><a href="#assign-sub-x-要自减的值" class="headerlink" title="assign_sub(x(要自减的值))"></a><code>assign_sub(x(要自减的值))</code></h3><ul>
<li>自减并返回更新后的值</li>
<li><p>调用assign _sub前，先用tf.Variable定义变量w为可训练（可自更新）。</p>
<p><br  /></p>
</li>
</ul>
<h2 id="条件语句-tf-where"><a href="#条件语句-tf-where" class="headerlink" title="条件语句 tf.where()"></a>条件语句 tf.where()</h2><ul>
<li><p>tf.where(条件, 返回值a, 返回值b) —— 若真返回a，若假返回b</p>
<p><br  /></p>
</li>
</ul>
<h2 id="判断值大小tf-greater-a-b"><a href="#判断值大小tf-greater-a-b" class="headerlink" title="判断值大小tf.greater(a,b)"></a>判断值大小tf.greater(a,b)</h2><ul>
<li><p>若a &gt; b, 则返回true，否则为false</p>
<p><br  /></p>
</li>
</ul>
<h2 id="Sequential搭建神经网络六步法-顺序网络结构"><a href="#Sequential搭建神经网络六步法-顺序网络结构" class="headerlink" title="Sequential搭建神经网络六步法(顺序网络结构)"></a>Sequential搭建神经网络六步法(顺序网络结构)</h2><ul>
<li><p>import相关模块</p>
<p><br  /></p>
</li>
<li><p>train、 test：告知要放入网络的训练集和测试集。指定训练集的的输入特征x_train和标签y_train、测试集的的输入特征x_test和标签y_test</p>
<p><br  /></p>
</li>
</ul>
<p>+<code>model = tf.keras.models.Sequential</code>: 在Sequential中搭建网络结构，逐层描述每层网络（走一遍前向传播）</p>
<ul>
<li><p>Sequential中封装了神经网络结构。</p>
<ul>
<li>拉直层：<code>tf.keras.layers.Flatten()</code>，把输入特征拉直变成一维数组。</li>
<li>全连接层：<code>tf.keras.layers.Dense(神经元个数, ctivation=&lt;激活函数&gt;, kernel_regularizer=&lt;哪种正则化&gt;)</code><ul>
<li>activation可选：relu, sogmoid, softmax, tanh…</li>
<li>kernel_regularizer可选:tf.keras.regularizers.’1(), tf.keras.regularizers.l2()…</li>
</ul>
</li>
<li>卷积层：<code>tf.keras,layers.Conv2D(filters=&lt;卷积核个数&gt;,kernel_size=&lt;卷积核步长&gt;, padding=&quot;valid&quot;/&quot;same&quot;)</code></li>
<li>LSTM层(循环层)：<code>tf.keras.layers.LSTM()</code></li>
</ul>
<p><br  /></p>
</li>
</ul>
<ul>
<li><p>model.compile: 在compile中配置训练方法：选择优化器、损失函数、评测指标。</p>
<ul>
<li><code>model.compile(optimizzer=&lt;优化器&gt;, loss=&lt;损失函数&gt;, matrics=[&quot;准确率&quot;])</code> —— 详细参数解析见<br>( <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1B7411L7Qt?p=15&amp;vd_source=28e3d226a5d356b023f32eac68624fb4">https://www.bilibili.com/video/BV1B7411L7Qt?p=15&amp;vd_source=28e3d226a5d356b023f32eac68624fb4</a></li>
</ul>
<p><br  /></p>
</li>
<li><p>model.fit: 在fit中执行训练过程。告知训练集和测试集的输入特征和标签，和每个batch，迭代次数。</p>
<ul>
<li><code>model.fit(训练集的输入特征,训练集的标签，batch_size=, epochs=, validation_data=(测试集的输入特征，测试集的标签), validation_split=从训练集划分多少比例给测试集, validation_freq=多少次epoch测试一次)</code></li>
</ul>
<p><br  /></p>
</li>
<li><p>model.summary: 打印出网络结构和参数统计。</p>
<p><br  /></p>
</li>
</ul>
<h2 id="class搭建神经网络结构六步法-带有跳连的结构-！！！（没懂，先放着）"><a href="#class搭建神经网络结构六步法-带有跳连的结构-！！！（没懂，先放着）" class="headerlink" title="class搭建神经网络结构六步法(带有跳连的结构)！！！（没懂，先放着）"></a>class搭建神经网络结构六步法(带有跳连的结构)！！！（没懂，先放着）</h2><p>  <br  /></p>
<h2 id="使用自制数据集"><a href="#使用自制数据集" class="headerlink" title="使用自制数据集"></a>使用自制数据集</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1B7411L7Qt?p=20&amp;vd_source=28e3d226a5d356b023f32eac68624fb4">https://www.bilibili.com/video/BV1B7411L7Qt?p=20&amp;vd_source=28e3d226a5d356b023f32eac68624fb4</a> </p>
<p><br  /></p>
</li>
</ul>
<h2 id="数据增强-增大数据量-：可以对少量数据进行不同的随机操作，从而产生新的数据。"><a href="#数据增强-增大数据量-：可以对少量数据进行不同的随机操作，从而产生新的数据。" class="headerlink" title="数据增强(增大数据量)：可以对少量数据进行不同的随机操作，从而产生新的数据。"></a>数据增强(增大数据量)：可以对少量数据进行不同的随机操作，从而产生新的数据。</h2><ul>
<li><p>Tensorflow2给出了数据增强函数</p>
<ul>
<li>要引入模块：from tensorflow.keras.preprocessing.image import ImageDataGenerator</li>
<li>image_gen_train = tf.keras.preprocessing.image.ImageDataGenerator(<br /><br>rescale = 所有数据将乘以阂数值, <br /><br>rotation_range  =  随机旋转角度数范围,<br /><br>width_shift_range  =  随机䆕度偏移量,<br /><br>height_shift_range  =  随机高度㐹移量,<br /><br>水平翻转: horizontal_flip = 是否随机水平翻转,<br /><br>随机缩放: zoom_range = 随机缩放的范围 [1-n, 1+n] )<br /><br><br /><br>image_gen_train.fit(x_train)<ul>
<li>这里的x_train需要一个四维数据，因此我们需要对其进行修改。</li>
<li>x_train = x_train.reshape(x_train.shape[0], 28, 28, 1) —— 新增一个维度，表示图片的通道数量。</li>
</ul>
</li>
<li>但使用这种数据增强后，传入fit的前三个数要以这种形式打包输入：model.fit(image gen train.flow(x_train, y_train, batch_size=32), …)</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="读取已训模型-ckpt文件"><a href="#读取已训模型-ckpt文件" class="headerlink" title="读取已训模型(ckpt文件)"></a>读取已训模型(ckpt文件)</h2><ul>
<li><p><code>model.load_weights(&quot;文件路径&quot;)</code></p>
<p><br  /></p>
</li>
</ul>
<h2 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h2><ul>
<li>tf.keras.callbacks.ModelCheckpoint(<br /> filepath=路径, <br /> save<em>weights</em> only=True/False,(是否只保留模型参数) <br /> save_best_only=True/False(是否只保留最优结果))</li>
<li><p>history = model.fit(…, callbacks=lcp_callback)，执行fit时加入callbacks参数来保存模型。在对应的目录下建立checkpoint文件夹，并返回模型给history？下次训练时会自动加载模型。</p>
<p><br  /></p>
</li>
</ul>
<h2 id="提取模型参数"><a href="#提取模型参数" class="headerlink" title="提取模型参数"></a>提取模型参数</h2><ul>
<li><p><code>model.trainable_variables</code> #返回模型中可训练的参数</p>
<ul>
<li>用print输出参数<ul>
<li>设置print输出格式：np.set printoptions(threshold=超过多少省略显示) #np.inf表示无限大 <br />print(model.trainable_variables)</li>
</ul>
</li>
<li>保存至文档中<ul>
<li>file = open(‘./weights.txt’, ‘w)<br />for v in model.trainable_variables:<br />file.write(str(v.name) + ‘ \n’)<br />file.write(str(v.shape) + ‘\n’)<br />file.write(str(v.numpy())+ ‘\n’)<br />file.close()</li>
</ul>
</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul>
<li><p>matplotlib库</p>
<p><br  /></p>
</li>
</ul>
<h2 id="给图识物（模型应用）"><a href="#给图识物（模型应用）" class="headerlink" title="给图识物（模型应用）"></a>给图识物（模型应用）</h2><ul>
<li><ol>
<li>搭建模型，已训好的模型</li>
</ol>
</li>
<li><ol>
<li>加载参数，即要放进网络的图片</li>
</ol>
<ul>
<li>要对放入的图片进行预处理，使其与训练集的图片的大小，颜色等一样。</li>
</ul>
</li>
<li><ol>
<li>预测结果，<code>result = predict(输入特征，batch_size=整数)</code></li>
</ol>
<p><br  /></p>
</li>
</ul>
<h2 id="TF中描述卷积层"><a href="#TF中描述卷积层" class="headerlink" title="TF中描述卷积层"></a>TF中描述卷积层</h2><ul>
<li><p>tf.keras.layers.Conv2D(<br>filters=卷积核个数,<br>kernel_size=卷积核尺寸, #正方形写核长整数，或(核高h,核宽w),<br>strides=滑动步长, #横纵向相同写步长整数，或(纵向步长h，横向步长w)，默认1<br>padding =“same” or “valid”,#使用全零填充是”same”，不使用是”valid”（默认)<br>activation= “ relu “ or “ sigmoid “ or “ tanh “ or “ softmax”等, #如有BN(批标准化操作)此处不写<br>input_shape=(高,宽,通道数)#输入特征图维度，可省略)</p>
<p><br  /></p>
</li>
</ul>
<h2 id="TF中描述批标准化"><a href="#TF中描述批标准化" class="headerlink" title="TF中描述批标准化"></a>TF中描述批标准化</h2><ul>
<li><p><code>tf.keras.layers.BatchNormalization()</code> #加在卷积层之后和激活层之前</p>
<p><br  /></p>
</li>
</ul>
<h2 id="TF中描述池化"><a href="#TF中描述池化" class="headerlink" title="TF中描述池化"></a>TF中描述池化</h2><ul>
<li>tf.keras.layers.MaxPoo12D(<br>pool_size=池化核尺寸，#正方形写核长整数，或（核高h，核宽w）— 以元组形式给出长宽<br>strides=池化步长，#步长整数，或(纵向步长h，横向步长w)<br>padding=’valid’or’same’)<h1 id="最大值池化"><a href="#最大值池化" class="headerlink" title="最大值池化"></a>最大值池化</h1></li>
<li><p>tf.keras.layers.AveragePooling2D(…)</p>
<h1 id="均值池化"><a href="#均值池化" class="headerlink" title="均值池化"></a>均值池化</h1><p><br  /></p>
</li>
</ul>
<h2 id="TF中描述舍弃"><a href="#TF中描述舍弃" class="headerlink" title="TF中描述舍弃"></a>TF中描述舍弃</h2><ul>
<li><p>在神经网络训练时，将一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复链接。</p>
<ul>
<li><code>tf.keras.layers.Dropout(舍弃的概率)</code> #舍弃概率的取值范围(0,1)</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h1 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h1><ul>
<li>卷积在图像识别神经网络中的作用，就是特征提取。卷积即特征提取器。</li>
</ul>
<h2 id="卷积核：卷积核层数与图像通道数相同，每层相应参数相乘求和，最终一起求和得到一个特征点。该过程称为卷积计算过程。提高卷积核数量可以提高特征提取能力。"><a href="#卷积核：卷积核层数与图像通道数相同，每层相应参数相乘求和，最终一起求和得到一个特征点。该过程称为卷积计算过程。提高卷积核数量可以提高特征提取能力。" class="headerlink" title="卷积核：卷积核层数与图像通道数相同，每层相应参数相乘求和，最终一起求和得到一个特征点。该过程称为卷积计算过程。提高卷积核数量可以提高特征提取能力。"></a>卷积核：卷积核层数与图像通道数相同，每层相应参数相乘求和，最终一起求和得到一个特征点。该过程称为卷积计算过程。提高卷积核数量可以提高特征提取能力。</h2><ul>
<li><p>卷积核的内容：几乘几，内容，层数，每次移动步长。</p>
<p><br  /></p>
</li>
</ul>
<h2 id="感受野：即经过提取后的特征图，在原图像上所占的大小（如5x5，感受野就是5，一般就是正方形）。不管经过几次计算，只与最终的特征图和原始图有关。"><a href="#感受野：即经过提取后的特征图，在原图像上所占的大小（如5x5，感受野就是5，一般就是正方形）。不管经过几次计算，只与最终的特征图和原始图有关。" class="headerlink" title="感受野：即经过提取后的特征图，在原图像上所占的大小（如5x5，感受野就是5，一般就是正方形）。不管经过几次计算，只与最终的特征图和原始图有关。"></a>感受野：即经过提取后的特征图，在原图像上所占的大小（如5x5，感受野就是5，一般就是正方形）。不管经过几次计算，只与最终的特征图和原始图有关。</h2><ul>
<li>感受野代表了特征提取能力，如果通过不同方式，最终提取出的特征图的感受野相同，那么他们的特征提取能力就相同。只是计算复杂度不同。取舍的情况要看具体的图片大小。（一般图片越大，则选择层数更多的提取方式）</li>
<li><p>例子：可用 两层3x3卷积核 替代 1层5x5卷积核。</p>
<p><br  /></p>
</li>
</ul>
<h2 id="全零填充：为了保证提取后的特征图与输入特征的大小一致"><a href="#全零填充：为了保证提取后的特征图与输入特征的大小一致" class="headerlink" title="全零填充：为了保证提取后的特征图与输入特征的大小一致"></a>全零填充：为了保证提取后的特征图与输入特征的大小一致</h2><ul>
<li><p>特征图边长：</p>
<ul>
<li>$ S A M E(  全0填充充  ) : \frac{\text { 边长 }}{\text { 步长 }} (向上取整) $ </li>
<li>$ VALID（不全0填充）: \frac{\text { 边长一核长 }+1}{\text { 步长 }} （向上取整）$</li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="批标准化-BN"><a href="#批标准化-BN" class="headerlink" title="批标准化(BN)"></a>批标准化(BN)</h2><ul>
<li>神经网络对0附近的数据更敏感：使数据位于激活函数的线性区（如sigmoid函数的0附近），使其更敏感</li>
<li>标准化:使数据符合0均值，1为标准差的分布。</li>
<li>批标准化:对一小批数据（batch），做标准化处理。</li>
<li>$ H<em>{i}^{\prime k}=\frac{H</em>{i}^{k}-\mu<em>{\mathrm{batch}}^{k}}{\sigma</em>{\mathrm{batch}}^{k}} $ #对每个像素点进行标准化<ul>
<li><script type="math/tex; mode=display">\\H_{i}^{k}  : 批标准化前, 第  \mathrm{k}  个卷积核, 输出特征图中第  \mathrm{i}  个像素点\\u_{\text {batch }}^{k}  : 批标准化前, 第  \mathrm{k}  个卷积核, batch张输出特征图中所有像素点平均值\\\sigma_{\text {batch }}^{k}  : 批标准化前, 第  k  个卷积核, batch张输出特征图中所有像素点标准差</script></li>
</ul>
</li>
<li>但如果仅使用 $ H<em>{i}^{\prime k}=\frac{H</em>{i}^{k}-\mu<em>{\mathrm{batch}}^{k}}{\sigma</em>{\mathrm{batch}}^{k}} $ 进行标准化，会使激活函数失去非线性区的特性。</li>
<li><p>通过下式拓宽区域，保证激活函数的非线性特性</p>
<ul>
<li><script type="math/tex; mode=display">\begin{array}{r}
X_{\mathrm{i}}^{k}=\gamma_{\mathrm{k}} \boldsymbol{H}_{\mathrm{i}}^{\boldsymbol{k}}+\boldsymbol{\beta}_{\mathrm{k}}\\
\begin{array}{cc}
\uparrow & \uparrow \\
\text { 缩放 } & \text { 偏移 } \\
\text { 因子 } & \text { 因子 }
\end{array}
\end{array}</script></li>
</ul>
<p><br  /></p>
</li>
</ul>
<h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><ul>
<li>池化用于减少特征数据量。取核范围内的最大值。</li>
<li><p>最大值池化可提取图片纹理,均值池化可保留背景特征。取核范围内的平均值。</p>
<p>&lt;br </p>
</li>
</ul>
<h2 id="舍弃"><a href="#舍弃" class="headerlink" title="舍弃"></a>舍弃</h2><ul>
<li><p>在神经网络训练时，将一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复链接。</p>
<p><br  /></p>
</li>
</ul>
<h2 id="搭建卷积神经网络层总结（CBAPD）"><a href="#搭建卷积神经网络层总结（CBAPD）" class="headerlink" title="搭建卷积神经网络层总结（CBAPD）"></a>搭建卷积神经网络层总结（CBAPD）</h2><ul>
<li>C：Convolutional:卷积计算层</li>
<li>B：BN：批标准化</li>
<li>A：Activation：激活函数</li>
<li>P：Pooling：池化</li>
<li><p>D：Dropout：舍弃</p>
<p><br  /></p>
</li>
</ul>
<h1 id="循环层"><a href="#循环层" class="headerlink" title="循环层"></a>循环层</h1><h2 id="循环核"><a href="#循环核" class="headerlink" title="循环核"></a>循环核</h2><p>  <br  /></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="特征与标签配对是什么意思？"><a href="#特征与标签配对是什么意思？" class="headerlink" title="特征与标签配对是什么意思？"></a>特征与标签配对是什么意思？</h2><ul>
<li>标签是用来标记特征是否有用的？</li>
<li>还是说标签指的是求解的目标。即如果要在一堆图片中找到猫的图片，则我在训练集中放入猫的图片并使这些图片的标签为猫。训练后，把测试集放入模型，最终它把测试集中最符合猫的图片标记为猫。</li>
</ul>
<h2 id="tf-GradientTape-一定要在with结构下使用吗？"><a href="#tf-GradientTape-一定要在with结构下使用吗？" class="headerlink" title="tf.GradientTape( )一定要在with结构下使用吗？"></a>tf.GradientTape( )一定要在with结构下使用吗？</h2><h2 id="如何使输入特征标准化？"><a href="#如何使输入特征标准化？" class="headerlink" title="如何使输入特征标准化？"></a>如何使输入特征标准化？</h2><ul>
<li>一般采取/255.0这样的操作。</li>
</ul>
<h2 id="什么是权重线？"><a href="#什么是权重线？" class="headerlink" title="什么是权重线？"></a>什么是权重线？</h2><h2 id="如何使初始参数中心化？"><a href="#如何使初始参数中心化？" class="headerlink" title="如何使初始参数中心化？"></a>如何使初始参数中心化？</h2><h2 id="有多少个分类，全连接层的最后一层就要有几个神经元？"><a href="#有多少个分类，全连接层的最后一层就要有几个神经元？" class="headerlink" title="有多少个分类，全连接层的最后一层就要有几个神经元？"></a>有多少个分类，全连接层的最后一层就要有几个神经元？</h2><h2 id="概率舍弃神经元有什么用？"><a href="#概率舍弃神经元有什么用？" class="headerlink" title="概率舍弃神经元有什么用？"></a>概率舍弃神经元有什么用？</h2><h2 id="卷积核内的参数是什么，为什么说是可以训练的？"><a href="#卷积核内的参数是什么，为什么说是可以训练的？" class="headerlink" title="卷积核内的参数是什么，为什么说是可以训练的？"></a>卷积核内的参数是什么，为什么说是可以训练的？</h2><h2 id="激活函数的非线性区和线性区分别有什么作用？"><a href="#激活函数的非线性区和线性区分别有什么作用？" class="headerlink" title="激活函数的非线性区和线性区分别有什么作用？"></a>激活函数的非线性区和线性区分别有什么作用？</h2><h2 id="各种优化器的区别和用途。"><a href="#各种优化器的区别和用途。" class="headerlink" title="各种优化器的区别和用途。"></a>各种优化器的区别和用途。</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/09/%E6%97%A5%E5%BF%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BenSQ">
      <meta itemprop="description" content="请按时午睡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午睡是一门学问">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/09/%E6%97%A5%E5%BF%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">日志基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-09 22:28:11 / 修改时间：22:37:07" itemprop="dateCreated datePublished" datetime="2022-10-09T22:28:11+08:00">2022-10-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="上传日志"><a href="#上传日志" class="headerlink" title="上传日志"></a>上传日志</h1><ol>
<li>进入Blog文件夹下打卡 Git Bash</li>
<li>输入 <code>hexo n &quot;&lt;filename&gt;&quot;</code> 此时会在posts文件夹下创建相应名字的md文档，可以打开进行编辑</li>
<li>输入 <code>hexo g</code> </li>
<li>输入 <code>hexo d</code> 完成上传</li>
</ol>
<h1 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h1><ol>
<li>在post文件夹下删除相应文章</li>
<li><code>hexo g</code></li>
<li><code>hexo d</code></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/09/Anaconda%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BenSQ">
      <meta itemprop="description" content="请按时午睡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="午睡是一门学问">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/09/Anaconda%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">Anaconda使用教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-09 21:53:25 / 修改时间：22:18:29" itemprop="dateCreated datePublished" datetime="2022-10-09T21:53:25+08:00">2022-10-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>创建新的Python环境（生成在envs文件夹下）</p>
<ul>
<li><code>conda create -n opencv python=3.7</code> 自动安装3.7版本的python，可选</li>
</ul>
</li>
<li><p>切换到新环境下操作</p>
<ul>
<li><code>activate opencv</code> 新环境的文件夹名</li>
</ul>
</li>
<li><p>在环境下安装指令</p>
<ul>
<li><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python</code> -i 后为下载源网址，否则为默认</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">BenSQ</p>
  <div class="site-description" itemprop="description">请按时午睡</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BenSQ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
